From d4da7c0854ee3794ddf2bd7ea0983e257b79f00b Mon Sep 17 00:00:00 2001
From: "lauren n. liberda" <lauren@selfisekai.rocks>
Date: Sat, 18 May 2024 21:34:24 +0200
Subject: [PATCH] Revert "ui: lazily create color map in color provider"

This reverts commit 3a3362de8e20f4ba5e8aca66185af8468dcb7d8d.
---
 ash/style/ash_color_mixer_unittest.cc         |   3 +
 ...rome_content_browser_client_browsertest.cc |   1 +
 .../themes/browser_theme_pack_unittest.cc     |   1 +
 ...erial_new_tab_page_color_mixer_unittest.cc |   1 +
 .../new_tab_page_color_mixer_unittest.cc      |   3 +
 chrome/browser/ui/color/tools/dump_colors.cc  |   1 +
 .../new_tab_page_handler_unittest.cc          |   2 +-
 .../web_contents_impl_browsertest.cc          |   2 +-
 .../web_contents_impl_unittest.cc             |   2 +-
 content/public/test/render_view_test.cc       |   2 +-
 extensions/browser/extension_host.cc          |   2 +-
 .../renderer/core/layout/layout_theme.cc      |   2 +-
 ui/base/models/image_model_unittest.cc        |   1 +
 ui/color/color_provider.cc                    | 188 +++++++-----------
 ui/color/color_provider.h                     |  39 ++--
 ui/color/color_provider_manager.cc            |   1 +
 ui/color/color_provider_unittest.cc           |   9 +
 ui/color/color_provider_utils.cc              |   4 +
 ui/color/color_provider_utils_unittest.cc     |   5 +-
 ui/color/sys_color_mixer_unittest.cc          |   1 +
 ui/native_theme/native_theme_base.cc          |   3 +-
 .../native_theme_fluent_unittest.cc           |   1 +
 ui/wm/core/shadow_controller_unittest.cc      |   1 +
 23 files changed, 142 insertions(+), 133 deletions(-)

diff --git a/ash/style/ash_color_mixer_unittest.cc b/ash/style/ash_color_mixer_unittest.cc
index 00d59b6e5ba..0a626166c12 100644
--- a/ash/style/ash_color_mixer_unittest.cc
+++ b/ash/style/ash_color_mixer_unittest.cc
@@ -37,6 +37,9 @@ void InitializeColorProvider(const ui::ColorProviderKey& key,
   // Roughly mimics the ColorMixer configuration for Ash.
   ash::AddCrosStylesColorMixer(&color_provider, key);
   ash::AddAshColorMixer(&color_provider, key);
+
+  // Populates the color map with computed color values.
+  color_provider.GenerateColorMap();
 }
 
 // Initializes the `color_provider` with `seed_color` and the relevant
diff --git a/chrome/browser/chrome_content_browser_client_browsertest.cc b/chrome/browser/chrome_content_browser_client_browsertest.cc
index b24f7e340a6..08f5820bba9 100644
--- a/chrome/browser/chrome_content_browser_client_browsertest.cc
+++ b/chrome/browser/chrome_content_browser_client_browsertest.cc
@@ -602,6 +602,7 @@ class PrefersColorSchemeTest
     explicit MockColorProviderSource(bool is_dark) {
       key_.color_mode = is_dark ? ui::ColorProviderKey::ColorMode::kDark
                                 : ui::ColorProviderKey::ColorMode::kLight;
+      provider_.GenerateColorMap();
     }
     MockColorProviderSource(const MockColorProviderSource&) = delete;
     MockColorProviderSource& operator=(const MockColorProviderSource&) = delete;
diff --git a/chrome/browser/themes/browser_theme_pack_unittest.cc b/chrome/browser/themes/browser_theme_pack_unittest.cc
index 4e6116ddbe8..e90d64d8e0b 100644
--- a/chrome/browser/themes/browser_theme_pack_unittest.cc
+++ b/chrome/browser/themes/browser_theme_pack_unittest.cc
@@ -750,6 +750,7 @@ TEST_F(BrowserThemePackTest, TestCreateColorMixersOmniboxAllValues) {
                                 "omnibox_background": [120, 140, 160] })";
   LoadColorJSON(color_json);
   theme_pack().AddColorMixers(&provider, ui::ColorProviderKey());
+  provider.GenerateColorMap();
   EXPECT_EQ(SkColorSetRGB(0, 20, 40), provider.GetColor(kColorToolbar));
   EXPECT_EQ(SkColorSetRGB(60, 80, 100), provider.GetColor(kColorOmniboxText));
   EXPECT_EQ(SkColorSetRGB(120, 140, 160),
diff --git a/chrome/browser/ui/color/material_new_tab_page_color_mixer_unittest.cc b/chrome/browser/ui/color/material_new_tab_page_color_mixer_unittest.cc
index 3fc2012f7a1..f1adab8b046 100644
--- a/chrome/browser/ui/color/material_new_tab_page_color_mixer_unittest.cc
+++ b/chrome/browser/ui/color/material_new_tab_page_color_mixer_unittest.cc
@@ -25,6 +25,7 @@ class MaterialNewTabPageColorMixerTest : public testing::Test {
   void AddMaterialColorMixers() {
     AddColorMixers(&color_provider_, color_provider_key_);
     AddChromeColorMixers(&color_provider_, color_provider_key_);
+    color_provider_.GenerateColorMap();
   }
 
  private:
diff --git a/chrome/browser/ui/color/new_tab_page_color_mixer_unittest.cc b/chrome/browser/ui/color/new_tab_page_color_mixer_unittest.cc
index 8d856905af2..d1733888717 100644
--- a/chrome/browser/ui/color/new_tab_page_color_mixer_unittest.cc
+++ b/chrome/browser/ui/color/new_tab_page_color_mixer_unittest.cc
@@ -33,6 +33,7 @@ TEST(NewTabPageColorMixer, LightAndDarkThemeColors) {
     if (color_utils::IsDark(toolbar_color))
       key.color_mode = ui::ColorProviderKey::ColorMode::kDark;
     AddNewTabPageColorMixer(&provider, key);
+    provider.GenerateColorMap();
 
     EXPECT_EQ(provider.GetColor(kColorToolbar), toolbar_color);
     EXPECT_EQ(provider.GetColor(kColorNewTabPageBackground), toolbar_color);
@@ -51,6 +52,7 @@ TEST(NewTabPageColorMixer, CustomColorComprehensiveThemeColors) {
   key.custom_theme =
       base::WrapRefCounted(new CustomThemeSupplier(ThemeType::kAutogenerated));
   AddNewTabPageColorMixer(&provider, key);
+  provider.GenerateColorMap();
 
   EXPECT_EQ(provider.GetColor(kColorToolbar), gfx::kGoogleGreen300);
   EXPECT_EQ(provider.GetColor(kColorNewTabPageBackground),
@@ -72,6 +74,7 @@ TEST(NewTabPageColorMixer, DefaultColorComprehensiveThemeColor) {
   key.custom_theme =
       base::WrapRefCounted(new CustomThemeSupplier(ThemeType::kAutogenerated));
   AddNewTabPageColorMixer(&provider, key);
+  provider.GenerateColorMap();
 
   EXPECT_EQ(provider.GetColor(kColorToolbar), kSampleToolbarColor);
   EXPECT_EQ(provider.GetColor(kColorNewTabPageBackground), kSampleToolbarColor);
diff --git a/chrome/browser/ui/color/tools/dump_colors.cc b/chrome/browser/ui/color/tools/dump_colors.cc
index 83f07c5c521..9cf5da9cd1d 100644
--- a/chrome/browser/ui/color/tools/dump_colors.cc
+++ b/chrome/browser/ui/color/tools/dump_colors.cc
@@ -56,6 +56,7 @@ int main(int argc, const char* argv[]) {
     ui::AddColorMixers(provider, key);
     color::AddComponentsColorMixers(provider, key);
     AddChromeColorMixers(provider, key);
+    provider->GenerateColorMap();
   };
   ui::ColorProvider light_provider, dark_provider, light_high_contrast_provider,
       dark_high_contrast_provider;
diff --git a/chrome/browser/ui/webui/new_tab_page/new_tab_page_handler_unittest.cc b/chrome/browser/ui/webui/new_tab_page/new_tab_page_handler_unittest.cc
index 82a8fd83218..63d7e6356a8 100644
--- a/chrome/browser/ui/webui/new_tab_page/new_tab_page_handler_unittest.cc
+++ b/chrome/browser/ui/webui/new_tab_page/new_tab_page_handler_unittest.cc
@@ -117,7 +117,7 @@ class MockLogoService : public search_provider_logos::LogoService {
 
 class MockColorProviderSource : public ui::ColorProviderSource {
  public:
-  MockColorProviderSource() = default;
+  MockColorProviderSource() { color_provider_.GenerateColorMap(); }
   MockColorProviderSource(const MockColorProviderSource&) = delete;
   MockColorProviderSource& operator=(const MockColorProviderSource&) = delete;
   ~MockColorProviderSource() override = default;
diff --git a/content/browser/web_contents/web_contents_impl_browsertest.cc b/content/browser/web_contents/web_contents_impl_browsertest.cc
index 0b48d2fa333..609ee453908 100644
--- a/content/browser/web_contents/web_contents_impl_browsertest.cc
+++ b/content/browser/web_contents/web_contents_impl_browsertest.cc
@@ -6329,7 +6329,7 @@ IN_PROC_BROWSER_TEST_F(WebContentsImplStarScanPrerenderBrowserTest,
 
 class MockColorProviderSource : public ui::ColorProviderSource {
  public:
-  MockColorProviderSource() = default;
+  MockColorProviderSource() { provider_.GenerateColorMap(); }
   MockColorProviderSource(const MockColorProviderSource&) = delete;
   MockColorProviderSource& operator=(const MockColorProviderSource&) = delete;
   ~MockColorProviderSource() override = default;
diff --git a/content/browser/web_contents/web_contents_impl_unittest.cc b/content/browser/web_contents/web_contents_impl_unittest.cc
index 5271f1b5e0b..faadce589cc 100644
--- a/content/browser/web_contents/web_contents_impl_unittest.cc
+++ b/content/browser/web_contents/web_contents_impl_unittest.cc
@@ -337,7 +337,7 @@ class MockPageBroadcast : public TestPageBroadcast {
 
 class TestColorProviderSource : public ui::ColorProviderSource {
  public:
-  TestColorProviderSource() = default;
+  TestColorProviderSource() { provider_.GenerateColorMap(); }
 
   const ui::ColorProvider* GetColorProvider() const override {
     return &provider_;
diff --git a/content/public/test/render_view_test.cc b/content/public/test/render_view_test.cc
index 1772fee94e2..498b1ebf5b1 100644
--- a/content/public/test/render_view_test.cc
+++ b/content/public/test/render_view_test.cc
@@ -150,7 +150,7 @@ class FailingURLLoaderFactory : public network::SharedURLLoaderFactory {
 
 class MockColorProviderSource : public ui::ColorProviderSource {
  public:
-  explicit MockColorProviderSource() = default;
+  explicit MockColorProviderSource() { provider_.GenerateColorMap(); }
   MockColorProviderSource(const MockColorProviderSource&) = delete;
   MockColorProviderSource& operator=(const MockColorProviderSource&) = delete;
   ~MockColorProviderSource() override = default;
diff --git a/extensions/browser/extension_host.cc b/extensions/browser/extension_host.cc
index 2bf778dd0c8..b7ea9c1ed5c 100644
--- a/extensions/browser/extension_host.cc
+++ b/extensions/browser/extension_host.cc
@@ -58,7 +58,7 @@ namespace {
 // the UI-less extension background page.
 class NoOpColorProviderSource : public ui::ColorProviderSource {
  public:
-  NoOpColorProviderSource() = default;
+  NoOpColorProviderSource() { color_provider_.GenerateColorMap(); }
   NoOpColorProviderSource(const NoOpColorProviderSource&) = delete;
   NoOpColorProviderSource& operator=(const NoOpColorProviderSource&) = delete;
   ~NoOpColorProviderSource() override = default;
diff --git a/third_party/blink/renderer/core/layout/layout_theme.cc b/third_party/blink/renderer/core/layout/layout_theme.cc
index 4b24a71c92a..7299605ce44 100644
--- a/third_party/blink/renderer/core/layout/layout_theme.cc
+++ b/third_party/blink/renderer/core/layout/layout_theme.cc
@@ -694,7 +694,7 @@ Color LayoutTheme::SystemColorFromColorProvider(
     CSSValueID css_value_id,
     mojom::blink::ColorScheme color_scheme,
     const ui::ColorProvider* color_provider) const {
-  CHECK(color_provider->HasMixers());
+  CHECK(!color_provider->IsColorMapEmpty());
   SkColor system_theme_color;
   switch (css_value_id) {
     case CSSValueID::kActivetext:
diff --git a/ui/base/models/image_model_unittest.cc b/ui/base/models/image_model_unittest.cc
index d9013ee6841..1d4a987a638 100644
--- a/ui/base/models/image_model_unittest.cc
+++ b/ui/base/models/image_model_unittest.cc
@@ -224,6 +224,7 @@ TEST(ImageModelTest, ShouldRasterizeEmptyModel) {
 
 TEST(ImageModelTest, ShouldRasterizeVectorIcon) {
   ui::ColorProvider color_provider;
+  color_provider.GenerateColorMap();
   gfx::ImageSkia image_skia =
       ui::ImageModel::FromVectorIcon(vector_icons::kSyncIcon)
           .Rasterize(&color_provider);
diff --git a/ui/color/color_provider.cc b/ui/color/color_provider.cc
index 1597715de1f..32ff2e41026 100644
--- a/ui/color/color_provider.cc
+++ b/ui/color/color_provider.cc
@@ -4,7 +4,6 @@
 
 #include "ui/color/color_provider.h"
 
-#include <forward_list>
 #include <map>
 #include <set>
 #include <utility>
@@ -18,106 +17,6 @@
 
 namespace ui {
 
-////////////////////////////////////////////////////////////////////////////////
-// ColorProvider::ColorProviderInternal:
-
-class ColorProvider::ColorProviderInternal {
- public:
-  using Mixers = std::forward_list<ColorMixer>;
-
-  ColorProviderInternal() = default;
-  ColorProviderInternal(const ColorProviderInternal&) = delete;
-  ColorProviderInternal& operator=(const ColorProviderInternal&) = delete;
-  ~ColorProviderInternal() = default;
-
-  ColorMixer& AddMixer() {
-    color_map_.clear();
-    mixers_.emplace_after(
-        first_postprocessing_mixer_,
-        base::BindRepeating([](const ColorMixer* mixer) { return mixer; },
-                            GetLastNonPostprocessingMixer()),
-        base::BindRepeating(&ColorProvider::ColorProviderInternal::
-                                GetLastNonPostprocessingMixer,
-                            base::Unretained(this)));
-
-    return *std::next(first_postprocessing_mixer_, 1);
-  }
-
-  ColorMixer& AddPostprocessingMixer() {
-    color_map_.clear();
-    if (first_postprocessing_mixer_ == mixers_.before_begin()) {
-      // The first postprocessing mixer points to the last regular mixer.
-      auto previous_mixer_getter = base::BindRepeating(
-          &ColorProvider::ColorProviderInternal::GetLastNonPostprocessingMixer,
-          base::Unretained(this));
-      mixers_.emplace_front(previous_mixer_getter, previous_mixer_getter);
-      first_postprocessing_mixer_ = mixers_.begin();
-    } else {
-      // Other postprocessing mixers point to the next postprocessing mixer.
-      auto previous_mixer_getter =
-          base::BindRepeating([](const ColorMixer* mixer) { return mixer; },
-                              base::Unretained(&mixers_.front()));
-      mixers_.emplace_front(previous_mixer_getter, previous_mixer_getter);
-    }
-    return mixers_.front();
-  }
-
-  SkColor GetColor(ColorId id) const {
-    auto i = color_map_.find(id);
-    if (i == color_map_.end()) {
-      if (mixers_.empty()) {
-        DVLOG(2) << "ColorProvider::GetColor: No mixers defined!";
-        return gfx::kPlaceholderColor;
-      }
-      DVLOG(2) << "ColorProvider::GetColor: Computing color for ColorId: "
-               << ColorIdName(id);
-      const SkColor color = mixers_.front().GetResultColor(id);
-      if (color == gfx::kPlaceholderColor) {
-        return gfx::kPlaceholderColor;
-      }
-      i = color_map_.insert({id, color}).first;
-    }
-
-    DVLOG(2) << "ColorProvider::GetColor: ColorId: " << ColorIdName(id)
-             << " Value: " << SkColorName(i->second);
-    return i->second;
-  }
-
-  const ColorMixer* GetLastNonPostprocessingMixer() const {
-    const auto it = std::next(first_postprocessing_mixer_, 1);
-    return (it == mixers_.cend()) ? nullptr : &(*it);
-  }
-
-  bool HasMixers() const { return !mixers_.empty(); }
-
-  void SetColorForTesting(ColorId id, SkColor color) { color_map_[id] = color; }
-
-  void GenerateColorMapForTesting() {
-    for (const auto& mixer : mixers_) {
-      const auto mixer_color_ids = mixer.GetDefinedColorIds();
-      for (const auto color_id : mixer_color_ids) {
-        GetColor(color_id);
-      }
-    }
-  }
-
-  const ColorProvider::ColorMap& color_map_for_testing() { return color_map_; }
-
- private:
-  // The entire color pipeline, in reverse order (that is, the "last" mixer is
-  // at the front).
-  Mixers mixers_;
-
-  // The first mixer in the chain that is a "postprocessing" mixer.
-  Mixers::iterator first_postprocessing_mixer_ = mixers_.before_begin();
-
-  // A cached map of ColorId => SkColor mappings for this provider.
-  mutable ColorMap color_map_;
-};
-
-////////////////////////////////////////////////////////////////////////////////
-// ColorProvider:
-
 ColorProvider::ColorProvider() = default;
 
 ColorProvider::ColorProvider(ColorProvider&&) = default;
@@ -127,31 +26,96 @@ ColorProvider& ColorProvider::operator=(ColorProvider&&) = default;
 ColorProvider::~ColorProvider() = default;
 
 ColorMixer& ColorProvider::AddMixer() {
-  return internal_->AddMixer();
+  DCHECK(!color_map_);
+
+  mixers_.emplace_after(
+      first_postprocessing_mixer_,
+      base::BindRepeating([](const ColorMixer* mixer) { return mixer; },
+                          GetLastNonPostprocessingMixer()),
+      base::BindRepeating(&ColorProvider::GetLastNonPostprocessingMixer,
+                          base::Unretained(this)));
+
+  return *std::next(first_postprocessing_mixer_, 1);
 }
 
 ColorMixer& ColorProvider::AddPostprocessingMixer() {
-  return internal_->AddPostprocessingMixer();
+  DCHECK(!color_map_);
+
+  if (first_postprocessing_mixer_ == mixers_.before_begin()) {
+    // The first postprocessing mixer points to the last regular mixer.
+    auto previous_mixer_getter = base::BindRepeating(
+        &ColorProvider::GetLastNonPostprocessingMixer, base::Unretained(this));
+    mixers_.emplace_front(previous_mixer_getter, previous_mixer_getter);
+    first_postprocessing_mixer_ = mixers_.begin();
+  } else {
+    // Other postprocessing mixers point to the next postprocessing mixer.
+    auto previous_mixer_getter =
+        base::BindRepeating([](const ColorMixer* mixer) { return mixer; },
+                            base::Unretained(&mixers_.front()));
+    mixers_.emplace_front(previous_mixer_getter, previous_mixer_getter);
+  }
+  return mixers_.front();
 }
 
 SkColor ColorProvider::GetColor(ColorId id) const {
-  return internal_->GetColor(id);
+  CHECK(color_map_);
+  auto i = color_map_->find(id);
+  return i == color_map_->end() ? gfx::kPlaceholderColor : i->second;
 }
 
-bool ColorProvider::HasMixers() const {
-  return internal_->HasMixers();
+void ColorProvider::GenerateColorMap() {
+  // This should only be called to generate the `color_map_` once.
+  DCHECK(!color_map_);
+
+  if (mixers_.empty())
+    DVLOG(2) << "ColorProvider::GenerateColorMap: No mixers defined!";
+
+  // Iterate over associated mixers and extract the ColorIds defined for this
+  // provider.
+  std::set<ColorId> color_ids;
+  for (const auto& mixer : mixers_) {
+    const auto mixer_color_ids = mixer.GetDefinedColorIds();
+    color_ids.insert(mixer_color_ids.begin(), mixer_color_ids.end());
+  }
+
+  // Iterate through all defined ColorIds and seed the `color_map` with the
+  // computed values. Use a std::map rather than a base::flat_map since it has
+  // frequent inserts and could grow very large.
+  std::map<ColorId, SkColor> color_map;
+  for (const auto& color_id : color_ids) {
+    SkColor resulting_color = mixers_.front().GetResultColor(color_id);
+    DVLOG(2) << "GenerateColorMap:"
+             << " Color Id: " << ColorIdName(color_id)
+             << " Resulting Color: " << SkColorName(resulting_color);
+    color_map.insert({color_id, resulting_color});
+  }
+
+  // Construct the color_map_.
+  color_map_ = ColorMap(color_map.begin(), color_map.end());
+
+  // Clear away all associated mixers as these are no longer needed.
+  mixers_.clear();
+  first_postprocessing_mixer_ = mixers_.before_begin();
 }
 
-void ColorProvider::SetColorForTesting(ColorId id, SkColor color) {
-  internal_->SetColorForTesting(id, color);  // IN-TEST
+bool ColorProvider::IsColorMapEmpty() const {
+  DCHECK(color_map_);
+  return color_map_->empty();
 }
 
-void ColorProvider::GenerateColorMapForTesting() {
-  internal_->GenerateColorMapForTesting();  // IN-TEST
+void ColorProvider::SetColorForTesting(ColorId id, SkColor color) {
+  if (color_map_) {
+    (*color_map_)[id] = color;
+  } else {
+    if (mixers_.empty())
+      AddMixer();
+    (*std::next(first_postprocessing_mixer_, 1))[id] = {color};
+  }
 }
 
-const ColorProvider::ColorMap& ColorProvider::color_map_for_testing() {
-  return internal_->color_map_for_testing();  // IN-TEST
+const ColorMixer* ColorProvider::GetLastNonPostprocessingMixer() const {
+  const auto it = std::next(first_postprocessing_mixer_, 1);
+  return (it == mixers_.cend()) ? nullptr : &(*it);
 }
 
 }  // namespace ui
diff --git a/ui/color/color_provider.h b/ui/color/color_provider.h
index 50fff33ae6a..80a5f00e036 100644
--- a/ui/color/color_provider.h
+++ b/ui/color/color_provider.h
@@ -5,11 +5,12 @@
 #ifndef UI_COLOR_COLOR_PROVIDER_H_
 #define UI_COLOR_COLOR_PROVIDER_H_
 
-#include <map>
+#include <forward_list>
 #include <memory>
 #include <optional>
 
 #include "base/component_export.h"
+#include "base/containers/flat_map.h"
 #include "third_party/skia/include/core/SkColor.h"
 #include "ui/color/color_id.h"
 #include "ui/color/color_mixer.h"
@@ -24,7 +25,7 @@ namespace ui {
 // TODO(pkasting): Figure out ownership model and lifetime.
 class COMPONENT_EXPORT(COLOR) ColorProvider {
  public:
-  using ColorMap = std::map<ColorId, SkColor>;
+  using ColorMap = base::flat_map<ColorId, SkColor>;
 
   ColorProvider();
   ColorProvider(const ColorProvider&) = delete;
@@ -48,25 +49,39 @@ class COMPONENT_EXPORT(COLOR) ColorProvider {
   // |id|.
   SkColor GetColor(ColorId id) const;
 
-  // Returns true if mixers is not empty. It's the case for some browser
+  // Generates the `color_map_` used by this provider for all ColorIds defined
+  // by attached mixers. After the map is generated attached mixers and their
+  // associated objects are discarded. Mixers should not be added to the
+  // provider after this has been called.
+  void GenerateColorMap();
+
+  // Returns true if the color_map_ is empty. It's the case for some browser
   // tests that run in single process mode but access colors that are
   // initialized on renderer process launch, for example, controls in
   // NaiveThemeBase and its children classes. Please see more details:
   // https://crbug.com/1376775.
-  bool HasMixers() const;
+  bool IsColorMapEmpty() const;
 
   void SetColorForTesting(ColorId id, SkColor color);
-  void GenerateColorMapForTesting();
-  const ColorMap& color_map_for_testing();
+  const ColorMap& color_map_for_testing() { return *color_map_; }
 
  private:
-  // ColorProviderInternal provides the actual implementation of ColorProvider.
-  // It's non-movable and non-copyable so that ColorMixer's callbacks can safely
-  // bind to it.
-  class ColorProviderInternal;
+  using Mixers = std::forward_list<ColorMixer>;
+
+  // Returns the last mixer in the chain that is not a "postprocessing" mixer,
+  // or nullptr.
+  const ColorMixer* GetLastNonPostprocessingMixer() const;
+
+  // The entire color pipeline, in reverse order (that is, the "last" mixer is
+  // at the front).
+  Mixers mixers_;
+
+  // The first mixer in the chain that is a "postprocessing" mixer.
+  Mixers::iterator first_postprocessing_mixer_ = mixers_.before_begin();
 
-  std::unique_ptr<ColorProviderInternal> internal_ =
-      std::make_unique<ColorProviderInternal>();
+  // A cached map of ColorId => SkColor mappings for this provider. This will be
+  // generated in the call to `GenerateColorMap()`.
+  std::optional<ColorMap> color_map_;
 };
 
 }  // namespace ui
diff --git a/ui/color/color_provider_manager.cc b/ui/color/color_provider_manager.cc
index 452f80c94d6..a0933fab350 100644
--- a/ui/color/color_provider_manager.cc
+++ b/ui/color/color_provider_manager.cc
@@ -109,6 +109,7 @@ ColorProvider* ColorProviderManager::GetColorProviderFor(ColorProviderKey key) {
     if (!initializer_list_->empty())
       initializer_list_->Notify(provider.get(), key);
 
+    provider->GenerateColorMap();
     RecordTimeSpentInitializingColorProvider(timer.Elapsed());
     ++num_providers_initialized_;
 
diff --git a/ui/color/color_provider_unittest.cc b/ui/color/color_provider_unittest.cc
index 884ab32d33a..34f57ef9f5e 100644
--- a/ui/color/color_provider_unittest.cc
+++ b/ui/color/color_provider_unittest.cc
@@ -17,6 +17,7 @@ namespace {
 // Tests that when there are no mixers, GetColor() returns a placeholder value.
 TEST(ColorProviderTest, GetColorNoMixers) {
   ColorProvider provider;
+  provider.GenerateColorMap();
   EXPECT_EQ(gfx::kPlaceholderColor, provider.GetColor(kColorTest0));
 }
 
@@ -25,6 +26,7 @@ TEST(ColorProviderTest, GetColorNoMixers) {
 TEST(ColorProviderTest, SingleMixer) {
   ColorProvider provider;
   provider.AddMixer()[kColorTest0] = {SK_ColorGREEN};
+  provider.GenerateColorMap();
   EXPECT_EQ(SK_ColorGREEN, provider.GetColor(kColorTest0));
   EXPECT_EQ(gfx::kPlaceholderColor, provider.GetColor(kColorTest1));
 }
@@ -35,6 +37,7 @@ TEST(ColorProviderTest, NonOverlappingMixers) {
   ColorProvider provider;
   provider.AddMixer()[kColorTest0] = {SK_ColorGREEN};
   provider.AddMixer()[kColorTest1] = {SK_ColorRED};
+  provider.GenerateColorMap();
   EXPECT_EQ(SK_ColorGREEN, provider.GetColor(kColorTest0));
   EXPECT_EQ(SK_ColorRED, provider.GetColor(kColorTest1));
 }
@@ -45,6 +48,7 @@ TEST(ColorProviderTest, OverlappingMixers) {
   ColorProvider provider;
   provider.AddMixer()[kColorTest0] = {SK_ColorGREEN};
   provider.AddMixer()[kColorTest0] = {SK_ColorRED};
+  provider.GenerateColorMap();
   EXPECT_EQ(SK_ColorRED, provider.GetColor(kColorTest0));
 }
 
@@ -55,6 +59,7 @@ TEST(ColorProviderTest, WithProcessing) {
   provider.AddMixer()[kColorTest0] = {SK_ColorBLACK};
   provider.AddPostprocessingMixer()[kColorTest0] =
       GetColorWithMaxContrast(FromTransformInput());
+  provider.GenerateColorMap();
   EXPECT_EQ(SK_ColorWHITE, provider.GetColor(kColorTest0));
 }
 
@@ -65,6 +70,7 @@ TEST(ColorProviderTest, WithProcessingAddedBeforeRegular) {
   provider.AddPostprocessingMixer()[kColorTest0] =
       GetColorWithMaxContrast(FromTransformInput());
   provider.AddMixer()[kColorTest0] = {SK_ColorBLACK};
+  provider.GenerateColorMap();
   EXPECT_EQ(SK_ColorWHITE, provider.GetColor(kColorTest0));
 }
 
@@ -76,6 +82,7 @@ TEST(ColorProviderTest, Redefinition) {
   mixer0[kColorTest0] = {SK_ColorBLACK};
   mixer0[kColorTest1] = AlphaBlend(SK_ColorRED, kColorTest0, 0x01);
   provider.AddMixer()[kColorTest0] = {SK_ColorWHITE};
+  provider.GenerateColorMap();
   EXPECT_EQ(SK_ColorWHITE, provider.GetColor(kColorTest0));
   EXPECT_FALSE(color_utils::IsDark(provider.GetColor(kColorTest1)));
 }
@@ -90,6 +97,7 @@ TEST(ColorProviderTest, RedefinitionWithProcessing) {
   provider.AddMixer()[kColorTest0] = {SK_ColorWHITE};
   provider.AddPostprocessingMixer()[kColorTest0] =
       GetColorWithMaxContrast(FromTransformInput());
+  provider.GenerateColorMap();
   EXPECT_NE(SK_ColorWHITE, provider.GetColor(kColorTest0));
   EXPECT_FALSE(color_utils::IsDark(provider.GetColor(kColorTest1)));
 }
@@ -97,6 +105,7 @@ TEST(ColorProviderTest, RedefinitionWithProcessing) {
 TEST(ColorProviderTest, SetColorForTesting) {
   ColorProvider provider;
   provider.SetColorForTesting(kColorTest0, SK_ColorGREEN);
+  provider.GenerateColorMap();
   EXPECT_EQ(SK_ColorGREEN, provider.GetColor(kColorTest0));
   EXPECT_EQ(gfx::kPlaceholderColor, provider.GetColor(kColorTest1));
   provider.SetColorForTesting(kColorTest1, SK_ColorBLUE);
diff --git a/ui/color/color_provider_utils.cc b/ui/color/color_provider_utils.cc
index e4300266484..816b6bd84b7 100644
--- a/ui/color/color_provider_utils.cc
+++ b/ui/color/color_provider_utils.cc
@@ -367,6 +367,7 @@ ColorProvider CreateColorProviderFromRendererColorMap(
 
   for (const auto& table : kRendererColorIdMap)
     mixer[table.color_id] = {renderer_color_map.at(table.renderer_color_id)};
+  color_provider.GenerateColorMap();
 
   return color_provider;
 }
@@ -425,6 +426,7 @@ ColorProvider CreateEmulatedForcedColorsColorProvider(bool dark_mode) {
   mixer[kColorSeparator] = {kColorMidground};
   CompleteDefaultNonWebNativeRendererColorIdsDefinition(mixer);
 
+  color_provider.GenerateColorMap();
   return color_provider;
 }
 
@@ -479,6 +481,7 @@ ColorProvider CreateEmulatedForcedColorsColorProviderForTest() {
   mixer[kColorWebNativeControlSliderHovered] = {SK_ColorCYAN};
   mixer[kColorWebNativeControlSliderPressed] = {SK_ColorCYAN};
 
+  color_provider.GenerateColorMap();
   return color_provider;
 }
 
@@ -652,6 +655,7 @@ ColorProvider COMPONENT_EXPORT(COLOR)
         SkColorSetRGB(0x37, 0x93, 0xFF)};
   }
 
+  color_provider.GenerateColorMap();
   return color_provider;
 }
 
diff --git a/ui/color/color_provider_utils_unittest.cc b/ui/color/color_provider_utils_unittest.cc
index bfbfe0b9ebe..b2b785b1fc9 100644
--- a/ui/color/color_provider_utils_unittest.cc
+++ b/ui/color/color_provider_utils_unittest.cc
@@ -49,6 +49,7 @@ TEST_F(ColorProviderUtilsTest, RendererColorMapGeneratesProvidersCorrectly) {
   ui::ColorMixer& mixer = color_provider.AddMixer();
   for (int i = ui::kUiColorsStart + 1; i < ui::kUiColorsEnd; ++i)
     mixer[i] = {static_cast<SkColor>(i)};
+  color_provider.GenerateColorMap();
 
   // The size of the RendererColorMap should match number of defined
   // RendererColorIds.
@@ -60,7 +61,6 @@ TEST_F(ColorProviderUtilsTest, RendererColorMapGeneratesProvidersCorrectly) {
   // also match the number of defined RendererColorIds.
   auto new_color_provider =
       ui::CreateColorProviderFromRendererColorMap(renderer_color_map);
-  new_color_provider.GenerateColorMapForTesting();
   EXPECT_EQ(kTotaltRendererColorIds,
             new_color_provider.color_map_for_testing().size());
 }
@@ -73,6 +73,7 @@ TEST_F(ColorProviderUtilsTest, ColorProviderRendererColorMapEquivalence) {
   for (int i = ui::kUiColorsStart + 1; i < ui::kUiColorsEnd; ++i) {
     mixer[i] = {static_cast<SkColor>(i)};
   }
+  color_provider.GenerateColorMap();
 
   // A renderer color map generated from its source provider should have
   // equivalent mappings.
@@ -84,6 +85,7 @@ TEST_F(ColorProviderUtilsTest, ColorProviderRendererColorMapEquivalence) {
   // Providers with different renderer color mappings should not be flagged as
   // equivalent.
   ui::ColorProvider new_color_provider;
+  new_color_provider.GenerateColorMap();
   EXPECT_FALSE(IsRendererColorMappingEquivalent(&new_color_provider,
                                                 renderer_color_map));
 }
@@ -119,6 +121,7 @@ TEST_F(ColorProviderUtilsTest, DefaultBlinkColorProviderColorMapsValidity) {
   ui::ColorProvider random_color_provider;
   ui::ColorMixer& mixer = random_color_provider.AddMixer();
   mixer[ui::kColorPrimaryBackground] = {SK_ColorWHITE};
+  random_color_provider.GenerateColorMap();
   ui::RendererColorMap random_color_map =
       ui::CreateRendererColorMap(random_color_provider);
 
diff --git a/ui/color/sys_color_mixer_unittest.cc b/ui/color/sys_color_mixer_unittest.cc
index 5552e96058a..46441498a87 100644
--- a/ui/color/sys_color_mixer_unittest.cc
+++ b/ui/color/sys_color_mixer_unittest.cc
@@ -36,6 +36,7 @@ class SysColorMixerTest
 
     AddRefColorMixer(&color_provider_, key);
     AddSysColorMixer(&color_provider_, key);
+    color_provider_.GenerateColorMap();
   }
 
  protected:
diff --git a/ui/native_theme/native_theme_base.cc b/ui/native_theme/native_theme_base.cc
index 11aa01fab19..45ccee8e9b4 100644
--- a/ui/native_theme/native_theme_base.cc
+++ b/ui/native_theme/native_theme_base.cc
@@ -1765,9 +1765,8 @@ bool NativeThemeBase::IsColorPipelineSupportedForControlColorId(
     ControlColorId color_id) const {
   // Color providers are not yet supported on Android so we need to check that
   // the color_provider is not null here.
-  if (!color_provider || !color_provider->HasMixers()) {
+  if (!color_provider || color_provider->IsColorMapEmpty())
     return false;
-  }
 
   static constexpr auto kControlColorIdsSet =
       base::MakeFixedFlatSet<ControlColorId>({kBorder,
diff --git a/ui/native_theme/native_theme_fluent_unittest.cc b/ui/native_theme/native_theme_fluent_unittest.cc
index 7f19986ddd0..01131e0105b 100644
--- a/ui/native_theme/native_theme_fluent_unittest.cc
+++ b/ui/native_theme/native_theme_fluent_unittest.cc
@@ -134,6 +134,7 @@ TEST_P(NativeThemeFluentTest, VerifyArrowRectWithArrowIcons) {
 TEST_F(NativeThemeFluentTest, PaintThumbRoundedCorners) {
   cc::RecordPaintCanvas canvas;
   ColorProvider color_provider;
+  color_provider.GenerateColorMap();
   constexpr gfx::Rect kRect(15, 100);
   // `is_web_test` is `false` by default.
   const NativeTheme::ScrollbarThumbExtraParams extra_params;
diff --git a/ui/wm/core/shadow_controller_unittest.cc b/ui/wm/core/shadow_controller_unittest.cc
index 05ba3b03adf..e384b66e3b3 100644
--- a/ui/wm/core/shadow_controller_unittest.cc
+++ b/ui/wm/core/shadow_controller_unittest.cc
@@ -285,6 +285,7 @@ TEST_F(ShadowControllerTest, SetColorsMapToShadow) {
   mixer[ui::kColorShadowValueAmbientShadowElevationTwelve] = {SK_ColorRED};
   mixer[ui::kColorShadowValueKeyShadowElevationTwentyFour] = {SK_ColorGREEN};
   mixer[ui::kColorShadowValueAmbientShadowElevationTwentyFour] = {SK_ColorBLUE};
+  color_provider.GenerateColorMap();
 
   shadow->SetElevationToColorsMap(
       ShadowController::GenerateShadowColorsMap(&color_provider));
