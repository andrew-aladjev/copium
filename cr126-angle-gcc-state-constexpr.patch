From 3a452a81f18b87fc904bd9b77e2412260722dcab Mon Sep 17 00:00:00 2001
From: "lauren n. liberda" <lauren@selfisekai.rocks>
Date: Sat, 18 May 2024 00:39:51 +0200
Subject: [PATCH] Revert "Cleanup: replace DirtyObjectType check with constexpr
 generator"

This reverts commit 89caa0e1d99e45f3d6f355f6e14c147f8de3e0e5.
---
 src/libANGLE/State.cpp |  2 ++
 src/libANGLE/State.h   | 60 ++++++++++++++++++------------------------
 2 files changed, 28 insertions(+), 34 deletions(-)

diff --git a/third_party/angle/src/libANGLE/State.cpp b/third_party/angle/src/libANGLE/State.cpp
index 24169c066..1f3de17a0 100644
--- a/third_party/angle/src/libANGLE/State.cpp
+++ b/third_party/angle/src/libANGLE/State.cpp
@@ -3966,4 +3966,6 @@ void State::initializeForCapture(const Context *context)
     initialize(mutableContext);
 }
 
+constexpr State::DirtyObjectHandler State::kDirtyObjectHandlers[state::DIRTY_OBJECT_MAX];
+
 }  // namespace gl
diff --git a/third_party/angle/src/libANGLE/State.h b/third_party/angle/src/libANGLE/State.h
index fa61701b3..b2aa67490 100644
--- a/third_party/angle/src/libANGLE/State.h
+++ b/third_party/angle/src/libANGLE/State.h
@@ -1448,40 +1448,13 @@ class State : angle::NonCopyable
 
     using DirtyObjectHandler = angle::Result (State::*)(const Context *context, Command command);
 
-    static constexpr std::array<DirtyObjectHandler, state::DIRTY_OBJECT_MAX> kDirtyObjectHandlers =
-        []() {
-            // Work around C++'s lack of array element support in designated initializers
-            std::array<DirtyObjectHandler, state::DIRTY_OBJECT_MAX> handlers{};
-
-            handlers[state::DIRTY_OBJECT_ACTIVE_TEXTURES]  = &State::syncActiveTextures;
-            handlers[state::DIRTY_OBJECT_TEXTURES_INIT]    = &State::syncTexturesInit;
-            handlers[state::DIRTY_OBJECT_IMAGES_INIT]      = &State::syncImagesInit;
-            handlers[state::DIRTY_OBJECT_READ_ATTACHMENTS] = &State::syncReadAttachments;
-            handlers[state::DIRTY_OBJECT_DRAW_ATTACHMENTS] = &State::syncDrawAttachments;
-            handlers[state::DIRTY_OBJECT_READ_FRAMEBUFFER] = &State::syncReadFramebuffer;
-            handlers[state::DIRTY_OBJECT_DRAW_FRAMEBUFFER] = &State::syncDrawFramebuffer;
-            handlers[state::DIRTY_OBJECT_VERTEX_ARRAY]     = &State::syncVertexArray;
-            handlers[state::DIRTY_OBJECT_TEXTURES]         = &State::syncTextures;
-            handlers[state::DIRTY_OBJECT_IMAGES]           = &State::syncImages;
-            handlers[state::DIRTY_OBJECT_SAMPLERS]         = &State::syncSamplers;
-            handlers[state::DIRTY_OBJECT_PROGRAM_PIPELINE_OBJECT] =
-                &State::syncProgramPipelineObject;
-
-            return handlers;
-        }();
-
-    static_assert(
-        []() {
-            for (auto handler : kDirtyObjectHandlers)
-            {
-                if (handler == nullptr)
-                {
-                    return false;
-                }
-            }
-            return true;
-        }(),
-        "kDirtyObjectHandlers missing a handler");
+    static constexpr DirtyObjectHandler kDirtyObjectHandlers[state::DIRTY_OBJECT_MAX] = {
+        &State::syncActiveTextures,  &State::syncTexturesInit,
+        &State::syncImagesInit,      &State::syncReadAttachments,
+        &State::syncDrawAttachments, &State::syncReadFramebuffer,
+        &State::syncDrawFramebuffer, &State::syncVertexArray,
+        &State::syncTextures,        &State::syncImages,
+        &State::syncSamplers,        &State::syncProgramPipelineObject};
 
     // Robust init must happen before Framebuffer init for the Vulkan back-end.
     static_assert(state::DIRTY_OBJECT_ACTIVE_TEXTURES < state::DIRTY_OBJECT_TEXTURES_INIT,
@@ -1495,6 +1468,25 @@ class State : angle::NonCopyable
     static_assert(state::DIRTY_OBJECT_READ_ATTACHMENTS < state::DIRTY_OBJECT_READ_FRAMEBUFFER,
                   "init order");
 
+    static_assert(state::DIRTY_OBJECT_ACTIVE_TEXTURES == 0,
+                  "check DIRTY_OBJECT_ACTIVE_TEXTURES index");
+    static_assert(state::DIRTY_OBJECT_TEXTURES_INIT == 1, "check DIRTY_OBJECT_TEXTURES_INIT index");
+    static_assert(state::DIRTY_OBJECT_IMAGES_INIT == 2, "check DIRTY_OBJECT_IMAGES_INIT index");
+    static_assert(state::DIRTY_OBJECT_READ_ATTACHMENTS == 3,
+                  "check DIRTY_OBJECT_READ_ATTACHMENTS index");
+    static_assert(state::DIRTY_OBJECT_DRAW_ATTACHMENTS == 4,
+                  "check DIRTY_OBJECT_DRAW_ATTACHMENTS index");
+    static_assert(state::DIRTY_OBJECT_READ_FRAMEBUFFER == 5,
+                  "check DIRTY_OBJECT_READ_FRAMEBUFFER index");
+    static_assert(state::DIRTY_OBJECT_DRAW_FRAMEBUFFER == 6,
+                  "check DIRTY_OBJECT_DRAW_FRAMEBUFFER index");
+    static_assert(state::DIRTY_OBJECT_VERTEX_ARRAY == 7, "check DIRTY_OBJECT_VERTEX_ARRAY index");
+    static_assert(state::DIRTY_OBJECT_TEXTURES == 8, "check DIRTY_OBJECT_TEXTURES index");
+    static_assert(state::DIRTY_OBJECT_IMAGES == 9, "check DIRTY_OBJECT_IMAGES index");
+    static_assert(state::DIRTY_OBJECT_SAMPLERS == 10, "check DIRTY_OBJECT_SAMPLERS index");
+    static_assert(state::DIRTY_OBJECT_PROGRAM_PIPELINE_OBJECT == 11,
+                  "check DIRTY_OBJECT_PROGRAM_PIPELINE_OBJECT index");
+
     // Dispatch table for buffer update functions.
     static const angle::PackedEnumMap<BufferBinding, BufferBindingSetter> kBufferSetters;
 
